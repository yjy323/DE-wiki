## 리뷰
### docker
- 대화식으로 컨테이너를 어떻게 구축하고 무엇이 좋은지 하둡을 직접 설치해보았다.
	1. Ubuntu를 베이스 이미지로 컨테이너를 실행한다.
	2. exec로 bash 터미널을 실행해 TTY로 접속한다.
	3. 순서대로 필요한 패키지를 설치한다.
	4. JDK와 Hadoop을 설치하고 환경변수를 설정한다.
	5. Hadoop이 정상적으로 설치되었는지 커맨드를 실행해 확인한다.
- 패키지를 설치하고 환경변수를 설정하는 일은 복잡성이 크지 않았고 커맨드에 익숙해지는데 시간이 더 걸렸다.
- 실행한 기록을 토대로 Dockerfile을 빠르게 작성할 수 있었다. 최초 빌드 시 약 30분이 소요되었다. 하지만 네트워크 속도의 영향이 큰 것 같다. 팀원은 약 1시간 30분이 소요되었다.
- 대화형으로 구축할 때, 도커파일을 이용할 때 둘다 환경변수에 오타가 있었는데, 확실히 이미지를 내리고 빌드하고 접속하고 확인하는 과정이 불필요하게 느껴졌다.
	- 하지만 docker가 Layer 단위로 관리되고 캐싱을 지원하기 때문에 절대적인 빌드 속도는 영향이 미미했다.
- 중간 쯤 되는 Layer를 수정해야 한다거나, 커맨드가 복잡한 경우라면 대화식으로 작성하는 것의 장점이 더 체감될 것 같다. 또, Dockerfile이 의도대로 동작할 지 모르는 불확실성이 있을 때는 빠르게 피드백 받을 수 있는 대화식 구축이 좋다고 생각한다.
- 이어서 Docker에서 제공하는 매뉴얼을 통해 Docker Engine을 학습해보았다.
	- 아직은 크게 체감되는 배움은 없었지만 도커를 더 많이 활용하게 되면 필요할 것 같다. 매일 조금씩 시간을 할애해 공부하는 것이 좋아보인다.
	- 주로 호스트 OS와 커널의 매커니즘과 깊은 관련이 있다.
### python multiprocessing
원래는 ETL 프로세스를 리팩토링 할 계획이었다.
1. 예외 케이스를 촘촘히 관리한다.
2. Transform 결과를 별도의 JSON으로 staging 할 지 결정한다. 그렇다면 코드를 수정한다.
3. pythonic하지 않거나 API로 대체할 수 있는 코드가 있는 지 점검한다.
그러다 5조 분들이 W2M4 관련해 multiprocessing 모듈에 대해 의논하는 것을 엿듣고 흥미로워보여서 함께 이것저것 실험하는데 시간을 거의 다 썼다.
이슈는 크게 2가지였다.
1. Queue가 논리적으로 절대 비어있을 수 없는데 Queue.Empty 예외가 발생한다.
2. 전체 작업 중 일부 작업에 대해 정상 종료되었다는 메시지는 콘솔 출력되었는데, 일부 작업 위치에서 프로세스가 정지한다.
	1. 이 동작은 마치 데드락이 발생한 것 처럼 보인다.
multiprocessing 공식 문서와 Stackoverflow를 활용해 원인과 해결 방법을 찾을 수 있었다.
1. 1번 이슈
	1. get()은 큐의 lock을 얻으려고 시도한다. 이 때 큐가 비어있다면 Empty 예외가 발생한다.
	2. 하지만 lock을 얻는 과정에서 timeout이 발생해도 Empty 예외가 발생한다.
	3. get_nowait()은 timeout이 즉시 발생하기 때문에 Empty 예외가 발생한 것이다.
	4. Empty가 아닌 별도의 Timeout과 같은 예외가 있었다면 논리적으로 이해하기 수월했을 것 같다. 왜 이렇게 구현했는 지 의도를 파악하지 못하겠다.
	5. exception을 별도로 handling 하지 않으면 프로세스가 종료된다. Non-Blocking I/O Pooling 방식과 같이 get_nowait()를 사용할 수도 있을 것이다.
2. 2번 이슈
	1. Queue에 대한 get과 put 작업은 별도의 스레드로 분기되어 처리된다. I/O 작업이므로 그럴 것이라는 점을 빠르게 파악했어야 했다.
	2. 또, Queue는 OS 수준의 파이프를 추상화한 것이다. 따라서 파이프 용량이 모자라면 스레드가 대기한다. 그리고 실험 코드에는 Queue에서 get()하는 코드가 join() 이후에 호출되도록 작성되었다.
	3. 즉, 정상 종료되었다는 메시지는 메인 스레드가 출력한 것이고, Queue에 I/O 작업을 하는 스레드는 Lock을 얻기 위해 대기하는 중인 것이다.
	4. 이때 메인 프로세스에서는 join()을 이용해 서브 프로세스가 종료되기를 기다리고 있다. 그러나 서브 프로세스는 I/O 스레드가 무한정 대기하기 때문에 절대 종료될 수 없다.
	5. 결론적으로 메인 프로세스와 서브 프로세스 사이에는 데드락이 발생하였다.
1, 2번 이슈를 통해 시행 횟수가 클 때 거의 반드시 의도하지 않은 동작이 발생한다는 것을 경험했다. 실제로 10, 100개의 입력값에 대해서는 두 케이스 모두 이슈가 발생하지 않았다.

그리고 모듈이 항상 의도대로 동작하지는 않는다. 두 문제의 해결법 중 하나는 multiprocessing.Manager 객체를 이용한 Queue 동기화였다. Queue 객체만으로는 프로세스간의 통신을 안정적으로 제어할 수 없는 것이다.

예상 가능한 문제를 떠올리는 것의 중요성, 실제로 발생한 문제에 대응하는 방법에 대해 배울 수 있었다.
## 회고
### KEEP
- 일반적으로 발생하거나 떠올리기 어려운 문제도 생각보다 쉽게 재현할 수 있다는 것을 경험했다. 사고를 확장할 수 있었다. 그리고 병렬/분산 환경에서 대용량 데이터를 처리하다보면 재현할 수 없는 문제도 많을 것이다. 이번에 겪은 문제의 답은 CS에 대한 높은 이해가 필요했다고 생각한다.
### PROBELM
- 
### TRY
- Docker와 Linux의 컨테이너 격리 기술, 프로세스와 스레드 같이 CS 배경 지식을 다노님의 제안대로 하루에 30분 이내로 틈틈히 공부하고 wiki에 작성해야겠다. 긴 시간 흥미를 갖고 집중하기는 어렵지만 꼭 필요한 습관이라고 생각한다.
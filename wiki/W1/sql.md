> **SQL** is a standard language for storing, manipulating and retrieving data in databases.

> SQLite는 별도의 서버 프로세스 없이 SQL을 사용하여 DB에 액세스할 수 있는 디스크 기반 경량 임베디드 DB이다.
<br> 파이썬은 내장된 SQLite 모듈을 통해 RDB를 관리할 수 있다.

SQLite3에는 다양한 기능이 있지만 쿼리 작성을 위한 기능과 개념 위주로 학습한다.
1. Connection과 Cursor 객체
2. SQL 실행
3. 트랜잭션 관리
4. 테이블 생성과 초기화
5. 쿼리 파라미터
6. 쿼리 실행 결과 처리

### 실행 흐름
1. DB 연결 및 커서 객체 생성
2. SQL 실행
3. 트랜잭션 관리
4. 자원 해제

### Connection과 Cursor
SQLite DB와 상호작용하는 핵심 역할
- Connection
  - DB와 파이썬 프로그램 간 연결을 관리한다.
  - DB 파일을 열거나 In-memory DB를 생성한다.
  - 트랜잭션을 제어한다.
    - connection.commit()
    - connection.rollback()
    - connection.close()
- Cursor
  - SQL 구문을 실행하고 결과 처리를 담당한다.
  - DB와 상호작용한다.
    - SQL 실행: cursor.execute()
    - 결과 조회: cursor.fetchX()

### 팀활동 요구사항
1. 쿼리 실행 순서
   1. GROUP BY와 HAVING, WHERE 사이의 실행 과정에 대해 대화를 나누며 SQL 키워드가 어떤 순서로 동작하는 지 이해할 수 있었다.
   2. 쿼리의 실행 순서를 제대로 이해해야 이후 최적화를 잘 할 수 있다.
      1. WHERE 절에서 Alias를 사용하려다가 원치 않는 결과를 받을 수 있다.
      2. ORDER BY 절에서 SELECT 절에서 이미 사용된 함수를 또 호출해서 자원이 낭비되는 것을 막아야 한다.
      3. 적절한 필터링을 통해 자원이 낭비되는 일을 방지해야 한다.
      4. FROM - JOIN - WHERE - GROUP BY - HAVING - SELECT - ORDER BY - LIMIT
2. IN, NOT IN의 내부 동작 과정과 서브쿼리
   1. 서브쿼리의 결과에 NULL이 존재할 때, IN 연산과 NOT IN 연산은 서로 반대되는 결과를 보인다.
   2. IN 연산은 모든 값과 OR 연산을, NOT IN은 AND 연산을 수행하기 때문이다.
   3. 따라서 서브쿼리 결과에 NULL이 존재하는 지 먼저 적절히 필터링을 해야 한다.
3. 트랜잭션, 커밋과 롤백의 동작 과정
   1. DB 클라이언트마다, ORM과 같은 프레임워크 마다 트랜잭션이 종료될 때 커밋하는 정책과 자원을 회수하는 방식이 다르다.
   2. 도한님은 ROLLBACK 기능을 포함하고자 했지만, 이를 명시하지 않더라도 COMMIT 하지 않는다면 반영되지 않으므로 ROLLBACK 한 것과 같은 동작이기를 기대하고 코드를 작성하였다.
   3. 하지만 팀원들과 소통하며 명시적으로 ROLLBACK 하는 것이 가독성 측면에서도 기술적 측면에서도 옳다는 것을 이해하고 오류를 수정할 수 있었다.
   4. 이어서 은태님의 설명을 통해 제품마다 다른 결과를 보일 수 있다는 것을 서로 이해할 수 있었다.
4. 저장 프로시저의 개념과 사용
   1. 저장 프로시저가 무슨 일을 하고 언제 사용할 수 있을 지 대화를 나누어 보았다.
   2. 저장 프로시저는 미리 정의(컴파일)된대로 효율적으로 동작하는 함수와 비슷한 개념으로 이해하였다. 추후 ETL 프로세스 등에서 Trigger와 같은 형태로 사용할 수 있을 것이라 기대한다. 그 때 더 자세한 학습이 필요할 것 같다.
   3. 컴파일 된 프로시저가 메모리에 적재되어 있다고 개념을 잘 못 이해하고 설명했는데, 은태님이 바로 잡아주었고 디스크에 위치하며 프로시저를 실행할 때만 로드한다고 정정하였다. '컴파일된 상태'라는 용어를 잘 못 이해하였다.